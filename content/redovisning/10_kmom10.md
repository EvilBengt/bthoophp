---
---
Redovisning kmom10
=========================

Detta innehåll är skrivet i markdown och du hittar innehållet i filen `content/redovisning/10_kmom10.md`.

Krav 1: Webbplats som demo
------

Förstasida, om-sida, header och footer är alla skrivna i Markdown.
Produktsidan har en egen kontroller `ProductController` och lika så
bloggen har en egen kontroller `BlogController`. De båda kontrollerna
är väldigt lika så jag kommer referera till dem båda som "kontrollern".

Kontrollern använder sig av `ContentFetcher` som tar emot en databaskoppling.
`ContentFetcher` har metoder för att hämta alla produkter, alla blogginlägg
och en metod för att hämta allt innehåll oavsett typ. När `ContentFetcher`
hämtar innehåll från databasen använder den `ContentFactory` som beroende
på `type`-kolumnen på var rad skapar en instans av antingen `Product` eller
`BlogPost`.

Båda dessa klasser ärver av den abstrakta `Content`-klassen som har alla
metoder och properties. Det enda `Product` respektive `BlogPost` gör är
att skriva över `getType()`-metoden hos `Content`. Tanken med att göra två
klasser var att funktionen mellan dem eventuellt skulle kunna skilja sig.
Det visade sig inte behövas, men på det sättet blir systemet enklare
att eventuellt bygga ut i framtiden.

Kontrollern har två routes, en för index och en för detaljer. Index-sidan
visar allt innehåll i en grid respektive lista med första raden från
brödtexten som sammanfattning/teaser. Detalj-sidan får id:t på innehållet
som ett argument i url:en och använder det för att hämta all data från
databasen. Båda sidorna använder `MyTextFilter` för att parsa
Markdown-texten.

Krav 2: Ordning och reda
------

Jag valde att skriva sidan som en aningen mer formell dokumentation genom
att strukturera upp den med underrubriker och listor. Jag beskriver de olika
kontrollernas allmänna funktion och router.

ER-diagrammet kommer från den inbyggda diagram-editorn i MySQL Workbench.
Jag använder den till ett eget projekt för att bygga databasstrukturen då
det är så pass komplext att jag inte längre varken kan hålla allt i huvudet
eller få någon översikt över tabellerna i en SQL-fil. Databasdelen av detta
projektet är så klart inte alls lika omfattande men jag har börjat gilla
designern i Workbench trots programmets suboptimala UI så jag håller mig
till det.

Enhetstestningen hade jag till en början inte tänkt så mycket på men mot
slutet bestämde jag mig för att ge mig på att testa i princip allt genom
att mocka hela strukturen i $this->app. Detta visade sig vara bra mycket
mer tidskrävande än jag klarade av i slutet så jag kom inte så långt på det.

Jag känner ändå att jag hade klarat av det om jag kanske hade haft en dag
till på mig dock, vilket känns lite surt. Jag har byggt upp en grund och
lite till med mock-klasser och sådant så jag har i alla fall kommit en
liten bit.

Jag antog från texten i uppgiften att PHPDoc kunde krångla och det visade
sig bli så för mig med. Som jag nämnde i dokumentationssidan körde jag
kommandot `make doc` en gång, och efter några minuters ostoppbart
stack-trace-och-errormeddelande-spottande gav jag upp och stoppade kommandot.
Jag har sedan dess testat igen men med samma resultat. Då det framgick
av kravspecen att det inte var så viktigt gjorde jag som den sade och gick
vidare med livet.

Krav 3: Administrativt gränssnitt
---------------------------------

Här används `AdminController` och de mer avancerade funktionerna hos
`Content` och `ContentFactory`. Alla routers kollar först om man är inloggad
(username och role=admin är satt i sessionen). Är det inte fallet,
omdirigeras man till `admin/login` som har ett enkelt inloggningsformulär.
När man väl är inloggad dirigeras man tillbaks igen till (`/admin`).

Inloggning/verifiering sker med hjälp utav `UserFetcher`- och
`AdminUser`-klasserna. `UserFetcher` tar emot ett användarnamn och returnerar
en `AdminUser` vid giltigt användarnamn och `false` vid ogiltigt.
`AdminUser`-klassen används sedan för att kontrollera lösenordet och för
att lagra användarens roll (enda möjliga värdet är för tillfället "admin"
men möjlighet finns för vidareutveckling).

Index-sidan visar en tabell över allt innehåll, oavsett typ. Typen redovisas
i en kolumn med översatt värde av `type`-kolumnen från databasen. (Egentligen
kommer värdet från `getType()`-metoden i `Product`- respektive
`BlogPost`-klasserna men det motsvarar för tillfället värdet från databasen.)
I tabellen finns även länkar till radera- och redigera-sidor.

Radera-sidan är ett enkelt förmulär med en knapp för att bekräfta borttagning.
Redigera-sidan har ett formulär med all nuvarande data ifylld.

Index-sidan har även ett formulär för att skapa nytt innehåll. Här kan man
dock endast välja titel, detta för att kunna kontrollera så titeln inte redan
används då den är primary key i databasen och därför måste vara unik.

När man skapar nytt eller redigerar innehåll tas formulärdatan om hand av
`ContentFactory`-klassen som gör om den till rätt klass. Det finns alltså
två sätt att skapa `Content`-objekt. `Content`-klassen har sedan själv metoder
för att uppdatera och lägga till sig i databasen. Databasreferensen måste
skickas med i dessa metoder då den endast används till dessa ändamål.

Allmänt om projektet
--------------------

Majoriteten av arbetet tycker jag har gått bra och jag är nöjd med de designval
jag gjort. Jag hade gärna lagt mer tid på enhetstestningen men man kan inte få
som man vill hela tiden...

Klasstrukturen och den allmänna uppbyggnaden av projektet tycker jag blev bra
och det finns bra möjligheter för vidareutveckling. Vissa av sakerna har man
kunnat lösa enklare/simplare men det hade riskerat att bli krångligt och
tungrott i längden.

Jag testade på lite, för mig, nya metoder i klasstrukturen som jag nog blev rätt
nöjd med. Jag hade till exempel vanligtvis valt att lägga allt om databasen i
en klass, men nu valde jag att flytta en del av det till `Content`-klassen.
Detta tycker jag gjorde att `Content`-objekten fick ett lite större syfte och inte
bara blev raka översättningar från databasen.

Rent generellt tycker jag nog att projektet var rimligt till kursen. Jag jobbade
med kmom06 första projektveckan så för mig har tiden varit väldigt begränsad
(klockan är nu 23:17). Hade man haft hela tiden på sig hade det varit mycket
lättare men det känns nog ändå som en relativt begränsad tid på man ska hinna med
den andra kursen med.

Allmänt om kursen
-----------------

Jag har alltid gillat och gillar fortfarande objektorienterad programmering, trots
att funktionell programmering börjar smyga sig in lite. PHP är även det första
programmeringsspråk jag lärt mig sedan jag började med Batch, Lua och C#. Trots det
är det nog tyvärr längst ner på favoritlistan med C# i toppen. Språket är känt för
att vara klumpigt och inkonsekvent, vilket jag kan intyga på.

Detta betyder dock inte att det inte är bra att kunna. Man kan nog knappast kalla
sig webbprogrammerare (i alla fall inte backend) utan att kunna PHP. Språkets
allmänt klumpiga känsla gör det hela lite mindre lockande och har gjort kursen till
min icke-favorit av de två kurserna jag läser parallellt. Detta betyder dock
definitivt inte att det är en dålig kurs då jag har lärt mig mängder av kanske
ibland mindre spännande men desto mer viktiga saker på de här veckorna.

Trots min inställning till språket (min inställning påverkar inte PHPs
användarstatistik) skulle jag inte ha några som helst problem att rekommendera kursen
då den behandlar ett mycket viktigt ämne som nog inte kommer långt i backend-världen
utan. Språket skulle nog få 4 eller 5 av tio från mig (det är inte alltid så hemskt)
men kursen förtjänar definitivt mer. Jag har inte sett något stort fel/problem i
kursen som jag kan komma ihåg i alla fall så en 10:a borde inte vara helt orimlig.
